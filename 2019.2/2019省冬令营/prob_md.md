「2019冬令营提高组」全连

> 还记得若干年前那段互相比较《克罗地亚狂想曲》的分数的日子吗？

E.Space 喜欢打音游。  

但是他技术不好，总是拿不到全连（Full Combo）。  

现在他面前有一份乐谱，乐谱的其中一段有 $n$ 个连续的单键音符。  

相邻两个音符的到来时间均相等，我们可以认为第 $i$ 个音符会在第 $i$ 个时刻到来。  

点击一个音符，E.Space 需要一段准备时间来进行移动手指之类的操作。由于音符的位置和周围情况不同，点击每个音符的准备时间也不同。  

在一个音符的准备时间内，E.Space 没法做到去点击其它音符，但是不同音符的准备时间范围可以互相重叠。形式化地，令第 $i$ 个音符的准备时间为 $t_i$ 个单位时间，那么如果 E.Space 选择去点击第 $i$ 个音符，那么他就没法点击所有到来时刻在 ($i − t_i$ ,$i + t_i$)中的音符。  

为了获得更高的分数，E.Space 还计算了每个音符的性价比。一个音符的性价比等于点击这个音符得到的分数除以 E.Space 点击它所需要的准备时间。  

E.Space 就不指望全连了，他只是想让你帮他计算一下他最多可以得到多少分数。  



从文件 `fc.in` 中读入数据。  
第一行一个正整数 $n$ 。  
第二行 $n$ 个正整数，第 $i$ 个正整数表示 $t_i$ 。  
第三行 $n$ 个正整数，第 $i$ 个正整数表示第 $i$ 个音符的性价比 $a_i$ 。  



输出到文件 `fc.out` 中。  
一行一个正整数，表示 E.Space 可能达到的最高分数。



### 样例 1 输入
```plain
5
2 3 2 1 2
3 1 2 9 4
```

### 样例 1 输出
```plain
18
```

### 样例 1 解释
E.Space 可以选择点击第 $1,3,5$ 个音符，分数为 $2 × 3 + 2 × 2 + 2 × 4 = 18$ 。



保证 $t_i \le n$ ，$a_i \le 10^9$

| 测试点编号 | $n \le $ |
| :--------: | :------: |
|     1      |    5     |
|     2      |    10    |
|     3      |    15    |
|     4      |    20    |
|     5      |   1000   |
|     6      |   2000   |
|     7      |   5000   |
|     8      |  10000   |
|     9      |  30000   |
|     10     |  50000   |
|     11     |  100000  |
|     12     |  200000  |
|     13     |  500000  |
|     14     |  800000  |
|     15     | 1000000  |
|     16     | 1000000  |
|     17     |  100000  |
|     18     |  100000  |
|     19     | 1000000  |
|     20     | 1000000  |

对于最后 4 个测试点，保证对于任意的 $i, j$ 有 $t_i = t_j$ 。



nealchen 是一只 copycat。  
它会把输入按行读入，原封不动地复制到输出中去。  
但是在一次更新以后，它的程序出了一些问题。  
它没法输出换行符了。  
并且，读入的时候，总会莫名其妙地随机漏掉开头和结尾的若干个字符，甚至整行都会漏掉。  
比如 $\text{orznight}$ 可能会变成 $\text{rzni}$ ，$\text{orz}$，$\text{h}$ 或者空串。  
现在你找到一份输入文件丢给 nealchen，你想知道它的输出可能有多少种情况，以及每种情况分别是什么。  
由于你找到的输入文件全部来自之前的福建省选，所以所有的输入文件每行只可能包含 $\text{A}$，$\text{C}$，$\text{G}$，$\text{T}$ 四种字符。  



从文件 `copy.in` 中读入数据。  
第一行一个正整数 $n$ ，表示（题面中）输入文件的行数。  
接下来 $n$ 行，表示输入文件的内容。保证这 n 行中每行的每个字符是 $\text{A}$，$\text{C}$，$\text{G}$，$\text{T}$四种字符中的一种。  
接下来一个整数 $k$($0 \le k \le 1$) ，具体含义详见输出格式。  



输出到文件 `copy.out` 中。  
若 $k = 0$ ，你需要输出一行，表示输出的可能情况个数模 $10^9 + 7$ 的结果。  
若 $k = 1$ ，你需要按照字典序从小到大输出所有可能的输出情况，一行一个字符串，最后一行输出输出的可能情况个数模 $10^9 + 7$ 的结果。

### 样例 1 输入
```plain
3
AC
CC
AA
0
```
### 样例 1 输出
```plain
22
```

### 样例 2 输入
```plain
3
AC
CC
AA
1
```

### 样例 2 输出
```plain
     
A
AA
AAA
AC
ACA
ACAA
ACC
ACCA
ACCAA
ACCC
ACCCA
ACCCAA
C
CA
CAA
CC
CCA
CCAA
CCC
CCCA
CCCAA
22
```

### 样例 2 解释
注意输出的第一行是一个空行，A为第二行。

对于 $40\%$ 的数据，$n = 1$   
对于 $60\%$ 的数据，$n < 3$   
对于 $100\%$ 的数据，保证输入文件大小不超过 1MB ，保证输出文件大小不超过 200MB 。

「2019冬令营提高组」不同的缩写



你在写一款 Galgame 的剧情（的代码）。  
在这个游戏中一共有 n 个角色。你需要编写一些关于这些角色的对话内容。然而，在写这些对话内容之前，都要写一段关于角色信息的代码，就像这样：  
$\text{Character("Alex", color = "#FFFC3A")}$  
你觉得这样好麻烦。你决定把它简化一下。你打算用角色名字的一个**非空子序列**（可以不连续）来作为它的简称。  



当然，不同的角色要用不同的字符串作为简称，否则你就变量重名了。  
你想确定一个简称的分配方案使得所有角色中最长的简称尽量短，这样你打起代码就会方便一些。



从文件 `diff.in` 中读入数据。  
第一行一个正整数 $n$ 。  
接下来 $n$ 行，每行一个由小写字母组成的字符串，代表一个角色的名字。  
不同的角色可能会有相同的名字。  



输出到文件 `diff.out` 中。  
如果不存在一种分配简称的方案满足条件，输出 `−1` 。  
否则第一行输出一个正整数，表示最长的简称的最小长度。  
接下来 $n$ 行每行一个字符串，按顺序表示每个角色的简称。  
**若有多种方案满足条件，那么你可以输出任意一种。**

### 样例输入

```plain
11
night
nealchen
beimingyouyu
echo
rankinf
dntcrybecthlev
lagoon
cyc
alphagem
leehwincing
clin
```

### 样例输出

```plain
1
g
a
m
e
r
b
o
y
l
w
c
```

保证 $n \le 300$ ，每个名字的长度不超过 $300$ 。  

***Subtask 1*（30 *pts*)** : $n \le 4$   
***Subtask 2*（30 *pts*)** :  $n \ge 100$ , 串长和串的内容在题目范围内均匀随机。    
即串长在 $[1,300]$ 内随机，串的每一位在 $a$ 到 $z$ 之间随机。  
***Subtask 3*（40 *pts*)**:  无特殊限制    

「2019冬令营提高组」直径



上午讲了构造题，下午就放一道构造题。你需要构造一棵至少有两个顶点的树，树上的每条边有一个非负整数边权。树上两点 $i,j$ 的距离 $dis(i,j)$ 定义为树上连接$i$ 和 $j$ 这两点的简单路径上的边权和。

我们定义这棵树的直径为，所有满足 $1\leq i<j \leq n$ 的 $(i,j)$ 中，$dis(i,j)$ 最大的。如果有多个这样的 $(i,j)$，那么均为直径。

作为一个构造题，你需要构造一个恰有 $k$ 个直径的树。可以证明在给定的限制下一定有解。



一行一个正整数 $k$，表示你需要构造出一个恰有 $k$ 个直径的树。



第一行一个正整数 $n$，表示你构造的树的点数。

接下来 $n-1$ 行，每行三个整数 $i,j,w$，表示一条连接点 $i$ 和 $j$ （点的编号为$1,2 \cdots n$）的树边，边权为 $w$。



#### 样例输入

```plain
3
```

#### 样例输出
```plain
5
1 2 2
3 2 2
2 5 3
4 2 2
```

#### 样例解释  
这只是一种符合题意的输出，可能还有其他输出。在这个输出中，直径为 $(1,5),(3,5),(4,5)$。

对于所有数据，$1 \leq k \leq 5000000$。

你构造的树需要保证 $2 \leq n \leq 5000$，且每条边的边权满足 $0 \leq w \leq 10^5$。

Subtask 1（10pts）：$1 \leq k \leq 5$。

Subtask 2（20pts）：$1 \leq k \leq 2000$。

Subtask 3（30pts）：$1 \leq k \leq 200000$。

Subtask 4（20pts）：$\sqrt{1+8k}$ 为整数。

Subtask 5（20pts）：无特殊限制。



「2019冬令营提高组」定价



作为 ByteLand 中最出色的开发者，你刚刚开发了一款新游戏。

为了赚更多的钱，这个游戏的主线剧情分为 $n$ 个DLC出售。你打算发行 $n$ 种预购套装，第 $i$（$1 \leq i \leq n$）种套装包含前 $i$ 个DLC。当然，第 $i$（$2 \leq i \leq n$） 个套装的价格需要严格高于第 $i-1$ 个套装的价格，并且第 $1$ 个套装的价格大于0。现在你需要确定这 $n$ 个价格。

在Byteland，所有物品的价格都只能为 $m$ 位二进制非负整数。此外，政府限制了每个价格的某些二进制位必须为 $0$。为了体现你是良心开发商，你需要求出所有 **套装** 的价格和的最小值。由于这个值可能太大了，你只需要输出它 $\bmod~10^9+7$ 后在十进制下的值。

天有不测风云，政策瞬息万变。一开始政府限制了每个价格的每个二进制位都必须为 $0$，后来随着时间推移，政府可能会允许某个价格的某个二进制位可以为 $1$，或重新限制某个二进制位必须为 $0$，你必须高效地对政策的变化作出反应，并随时支持求出价格和的最小值。



第一行三个正整数 $n,m,q$，$q$ 表示操作个数。

接下来 $q$ 行，每行为两者之一：

- `1 r c` : 表示第 $r$ 个套装的价格的从高到低第 $c$ 位（即位权为 $2^{m-c}$ 的一位）由于政策调整发生了变化。如果原来必须为 $0$则现在可以为 $1$，否则现在必须为 $0$。  
-  `2` : 表示询问所有 \textbf{套装} 的价格和的最小值，详见输出格式。



对所有 $2$ 操作输出一行：如果不存在合法的定价方案输出 $-1$，否则输出所有 \textbf{套装} 的价格和的最小值 $\bmod~10^9+7$ 后十进制下的值。

#### 样例输入1
```plain
3 4 6
1 2 3
1 3 2
2
1 2 4
1 1 4
2
```

#### 样例输出1
```plain
-1
7
```

#### 样例输入2
```plain
1 1000000000 3
2
1 1 1
2
```

#### 样例输出2
```plain
-1
570312504
```

对于所有数据，$1 \leq n \leq 1000$，$1 \leq m \leq 10^9$，$1 \leq q \leq 500000$。\textbf{$2$ 操作的个数不超过 $1000$。}

Subtask 1（10pts）：$n=1$。

Subtask 2（15pts）：$1 \leq n,m \leq 300$。

Subtask 3（25pts）：$1 \leq m \leq 10000$。

Subtask 4（25pts）：$1 \leq q \leq 5000$。

Subtask 5（25pts）：无特殊限制。

由于输入输出量较大，下发文件中有 `io.cpp`，选手可以参考。注意评测时并不会附加该文件，如果你需要使用它可以直接拷贝其源代码。



「2019冬令营提高组」排序



zzq近日发明了一种最新的排序算法 $\text{FastSort}$，它的伪代码大致如下：

![](/problem/2/testdata/download/183_1.png)  



当然，这个伪代码里的 $cnt$ 对排序来说没什么用，它只是用来指示这个算法的运行效果的。

zzq很喜欢这个算法，于是他打算用它来给一个 $1,2 \ldots n$ 的排列 $a$ 排序。为了清楚地获取算法的运行过程，zzq决定在每次 $cnt$ 改变时记录下当前的 $cnt$ 和 $a$ 便于分析。

zzq运行了这个算法之后就睡觉去了。第二天早上，zzq发现昨天停电了，日志里只剩下了记录下的最后一个 $cnt$ 和 $a$。zzq不想再运行一遍算法了，于是他想让你确认一下记录是否正确。

一句话题意：对给定的 $1,2 \ldots n$ 的排列 $a$ 执行算法 $\text{FastSort}$，问当 $cnt$ 刚刚变成输入中给定的值时的 $a$ 序列。



第一行两个整数，$n$ 和 $cnt$。

第二行 $n$ 个整数，表示 $a_1,a_2 \ldots a_n$。保证是一个 $1,2 \ldots n$ 的排列。

一行 $n$ 个整数，表示 $cnt$ 恰好变成给定值时的 $a$ 序列。

#### 样例输入1
```plain
5 3
4 3 2 5 1
```

#### 样例输出1
```plain
2 4 3 5 1
```

#### 样例输入2
```plain
9 16
1 9 8 2 3 7 5 4 6
```

#### 样例输出2
```plain
1 2 8 9 3 7 5 4 6
```


对于所有数据，$2 \leq n \leq 10^6,1 \leq cnt \leq \frac{n(n-1)}{2}$。\par

Subtask 1（10pts）：$cnt \leq 10^7$。

Subtask 2（10pts）：$a_i=n+1-i$。

Subtask 3（20pts）：数据生成方式为，先选定 $n \leq 100000$ 和 $cnt$，并初始化 $a_i=i$（$\forall i \in [1,n]$），然后重复 $10$ 次，每次在 $[1,n]$ 中独立均匀随机两个不同的整数 $i$ 和 $j$，并交换 $a_i$ 和 $a_j$。

Subtask 4（20pts）：$n \leq 50000$。

Subtask 5（20pts）：$n \leq 200000$。

Subtask 6（20pts）：无特殊限制。

由于输入输出量较大，下发文件中有 `io.cpp`，选手可以参考。注意评测时并不会附加该文件，如果你需要使用它可以直接拷贝其源代码。