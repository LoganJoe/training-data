20 210 222


高斯消元求矩阵的秩

3 3
2 0 2
0 2 0
2 0 2

3 3
3 2 9
6 1 2
3 4 7

这题做法是贪心，把每个向量的花费从小到大排序，然后能放就放。

主要是判断放入一个向量之后，是不是线性无关的。所以我们去求矩阵的秩，看是否增加了1。

和一般的高斯消元不同，一般的是用当前行去消其他行，而这个是用其他行消当前行...为了方便，记录一个vis[j]数组，表示第j列（第j列非0）的向量编号。

消元时候枚举当前行的元素，然后直接用vis[j]这个向量去消当前行就行了。如果vis[j]没有向量，那么秩一定增加了1，所以令vis[j]为当前行，跳出消元。








#include <cstdio>
using namespace std;
int main()
{   int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
      for (int j=i+1;j<=m;j++)    
        printf("%d %d\n"
} 







给一棵边带字符的树，每次询问一个串s在u到v的路径上出现了多少次

http://codeforces.com/contest/917/problem/E

假设是根到v的路径上出现多少次，建立从前到后的主席树，存着每个节点在后缀自动机上的节点，子树中存在着多少，树剖维护后缀树上节点个数，支持子树+1，单点查询

根到v的答案-根到u的答案-（O(n)枚举）。对Trie建SAM，然后每个点建主席树保存从根到它，每个后缀自动机节点的出现次数


COT5
https://vjudge.net/problem/CodeChef-COT5

Treap 


BZOJ3499


