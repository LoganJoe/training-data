---
title: " DTOJ3875Tree\t\t"
tags:
  - 分块
  - 奇技淫巧
url: 3829.html
id: 3829
categories:
  - Solution
date: 2018-09-04 07:54:23
---

考虑分块。按标号分块，记$f\[i\]\[j\]$为第$i$块内的点到$j$的距离和。那么我们对于整块的考虑分块，剩下的直接暴力计算。问题是如何维护$f\[i\]\[j\]$。

首先我们可以用dfs+换根的做法求出所有初始的$f\[i\]\[j\]$。具体地，我们记$cnt\[i\]\[j\]$为以$j$为根的子树中有多少第$i$块内的点。然后就可以快速计算$f\[i\]\[j\]$。现在我们要考虑修改，那么我们关注一条边对于答案的影响。

同样的，我们考虑一条$x \\Rightarrow v$，边权改变了$\\delta$。那么$v$子树中的每个点，到外面的距离都改变了$\\delta$，子树外的每个点到子树内的距离也改变了$\\delta$。那么这些对于每一块产生的贡献都可以用$cnt\[i\]\[1\],cnt\[i\]\[v\]$算出。

于是我们可以在每一块内，用树状数组维护$f\[i\]\[j\]$的前缀和，并且支持区间增减。这样我们处理了块的询问。

考虑暴力计算。那么对于剩下的一些点，距离就是$deep\[x\]+deep\[y\]-2*deep\[lca\]$。$deep\[lca\]$可以看成是$y$到根的路径以外边权全部为0，然后$x$到根的路径长度。我们可以树状数组维护深度和解决。

那么在上面，两个部分的修改与查询效率分别是这样的：

整块计算 修改$O(n \\sqrt n log n)$，查询$O(log n)$

暴力计算 修改$O(log n)$，查询$O(\\sqrt n log n)$

这样总体的复杂度是$O(n  \\sqrt n log n)$考虑如何平均复杂度。分块的复杂度比较死，我们考虑优化掉$log$。而$log$的复杂度是由求$lca$和$BIT$带来的。

求lca我们可以用$RMQ$找区间深度最小的点的编号，就可以预处理$O(n \\log n)$，询问$O(1)$求出lca。

先考虑优化暴力的树状数组。我们考虑将原有的信息使用分块维护。那么修改效率是$O(\\sqrt n)$，查询效率是$O(1)$单次的。查询次数至多$O(\\sqrt n)$，那么现在暴力计算的时间复杂度变为：

修改$O(\\sqrt n)$，查询$O(\\sqrt n)$

如何考虑块内前缀和。对于修改，我们要改变所有块的值，共$O(\\sqrt n)$次操作，原来每次操作是树状数组$O(log)$的。我们实现一个$O(1)$修改，$O(\\sqrt n)$询问的分块，来维护那个前缀和。具体地，每次查询是跑x前面所有块和零散块的答案，支持的操作是单点加。那么现在效率变为了：

修改$O(\\sqrt n)$，查询$O(\\sqrt n)$

询问的时候我们可以拆成问$1 - a-1$ 和$1-b$的计算答案。