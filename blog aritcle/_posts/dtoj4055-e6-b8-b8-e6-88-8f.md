---
title: " DTOJ4055游戏\t\t"
tags:
  - dp
  - 倍增
  - 决策单调性
  - 思路
  - 矩阵
  - 贪心
url: 5538.html
id: 5538
categories:
  - Solution
date: 2018-12-16 11:23:34
---

首先要想到如何取是最优的。 注意到题目中有一个限制是$a\_i < b\_i$。 设$S=\\max(b\_ip\_i)$。假设我们完成了一个任务并且获得了一次升级的机会，那么我们接下来肯定会用这个机会去升级期望收益最大的任务，并且之后一直尝试完成这个任务。而后每秒都可以获得$+S$的期望收益。可以发现这样肯定会比其他的方案优。 那么这样的话，$dp$状态只会和时间有关。考虑$f\_t$为还剩下$t$秒的时间，所能获得的最大期望收益。那么可以写出状态转移： $$ f\_{t+1}=\\max(p\_i(a\_i+tS)+(1-p\_i)f\_t) $$ 这个是前三个Subtask的算法。效率$\\Theta(nT)$。 考虑优化。整理一下原式子，发现 $$ f_{t+1} = \\max(p_{i} (a_{i} + tS) + (1 - p_{i}) f_{t}) = f_{t} + max(p_{i} (tS - f_{t}) + p_{i} a_{i}) $$ 那么对于每次转移，相当于是取$x=tS+f\_t$上，$p\_ix+p\_ia\_i$的最大值。我们将每个任务看作是一条斜率为$p\_i$，截距为$p\_ia\_i$的直线，那么我们可以建出凸壳，有用的就只有凸壳上的直线了。 那么每次枚举$T$，单调栈维护一个凸包。$\\Theta(n \\log n + T \\log n)$可以额外获得25pts。 考虑优化过程。首先，我们可以证明$tS+f\_t$单调不降，即$f_{t+1}-f\_t \\le S$。这个很显然，因为假设存在更优解，那么这个解的$p\_ib\_i$肯定会大于$S$。于是我们在凸包上面的移动就是随着$t$单调的了。考虑对于一个确定的直线去更新dp时，用矩阵乘法优化： $$ \\begin{pmatrix} dp\_{t+1} \\\ t+1 \\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 - p_{i} & p_{i} M & p_{i} a_{i} \\\ 0 & 1 & 1 \\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} dp_{t} \\\ t \\\ 1 \\end{pmatrix} $$ 那么我们可以每次二分当前直线不优的位置，然后矩阵快速幂优化矩阵乘法去判断。这样的效率是$\\Theta(n \\log n + T \\log^2 )$的。会被卡。 但是我们可以直接倍增那个位置，于是效率就降到了$\\Theta(n \\log n + T \\log )$了。