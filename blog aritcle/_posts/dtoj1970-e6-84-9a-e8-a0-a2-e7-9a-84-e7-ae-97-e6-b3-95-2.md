---
title: " DTOJ1970愚蠢的算法\t\t"
tags:
  - dp
  - 思路
url: 4997.html
id: 4997
categories:
  - DTOJ
  - Solution
date: 2018-11-02 15:14:22
---

将$p\_i$与$p\_j$交换，代价$2|i-j|-1$。是不是有点似曾相识？仔细想想，这个就是通过冒泡排序交换$p\_i$和$p\_j$需要的次数。 冒泡排序将序列排成有序的，交换次数是序列的逆序对数，即$f(p)=p的逆序对数$。 再来考虑$\\max(0,i-p\_i)$是什么。$i$之前比$p\_i$小的最多有$p\_i-1$个，那么$i-p\_i$就是$i$之前最少可能比$p\_i$大的数，也就是至少同$i$产生的逆序对数。 那么就显然有$f(p)\\geq g(p)$。 并且每次往排列里插入一个数，$f$的增加量一定$\\geq$$g$的增加量。 因此如果要使$f(p)=g(p)$，就要保证每次往排列里加数时，$f$的增加量都等于$g$的增加量。 假如我们现在有一个长度为$i$的排列$p$，且有$f(p)=g(p)$。考虑往排列里插入$i+1$得到排列$p'$，要如何使得$f(p')=g(p')$。 如果$i+1$放在最后面，那么逆序对个数没有增加，所以$f(p')=f(p)$。并且$\\max(0,i+1-p\_{i+1})=0$，所以$g(p')=g(p)$。所以就有$f(p')=g(p')$，这是合法的。 如果$i+1$放在第$j$个数前面，那么逆序对增加了$i+1-j$个，所以$f(p')=f(p)+i+1-j$。因此$g(p')$也要增加$i+1-j$。对于之前在第$j$个数前面的数，它们对$g(p')$是没有贡献的。也就是说，对于原来的第$k$个数($k\\geq j$)，$\\max(0,k+1-p\_k)=\\max(0,k-p\_k)+1$。那么就肯定有$k-p\_k\\geq 0$。 到这里我们就可以开始dp了。 先考虑$m=0$的情况。 记$f\[i\]\[j\]$为长度为$i$的排列$p$，满足$f(p)=g(p)$，并且最后$j$个数都满足$k-p\_k\\geq 0$的方案数。 根据前面的分析，很容易得到转移 $$f\[i\]\[j\]=f\[i-1\]\[j-1\]+\\sum_{k=j}^{i-1}f\[i-1\]\[k\]$$ 化简后可以得到 $$f\[i\]\[j\]=f\[i-1\]\[j-1\]+f\[i\]\[j+1\]$$ 考虑有限制的情况。 对于已经确定位置的元素$i$，在计算$f\[i\]\[j\]$时，只能用$i$的位置去转移，即我们不能枚举$i$放在哪。 对于没有确定位置的元素$i$，在计算$f\[i\]\[j\]$时，由于$1\\sim i-1$有些元素的位置是确定的，因此我们可以知道$i$前面至少有多少个元素。我们枚举$i$的位置时保证前面有这么多数即可。