---
title: " DTOJ3875Tree\t\t"
tags:
  - 分块
  - 奇技淫巧
url: 3655.html
id: 3655
categories:
  - DTOJ
  - Solution
date: 2018-08-27 22:23:10
---

此题是[DTOJ3559简单树题](http://www.dtenomde.com/2018/03/author=jiangyutong/article=1077/)的加强版。 写完这道题我才发现其实我3559写丑了，不用这么复杂的。 我们先把所有边权看成$0$，然后再一条条改过去。 我们只要实现修改和查询操作即可。 思路和3559相同，但3559的时间和空间复杂度都是$\\Theta(n\\sqrt n\\log n)$，在这题是过不去的。 考虑如何优化。按标号分块感觉不能优化了，我们考虑把$\\log$去掉。 $\\log$主要是树状数组和求$LCA$带来的。 求$LCA$我们可以改成$\\Theta(1)$求，即在dfs的时候把一个点加入多次，然后RMQ预处理区间深度最小的点，就可以做到$\\Theta(1)$询问了。 接着考虑树状数组。 树状数组分为两类，一个是维护$deep\_x$的，另外有$\\sqrt{n}$个是维护按下标分块后每块的点到每个点的距离和，是以dfs序为下标建的树状数组。 先考虑优化维护$deep\_x$的。 修改边权对$deep_x$的影响是一个区间加，查询是$\\sqrt{n}$次单点查询。 用树状数组维护肯定不行了。我们可以再用分块维护，这样区间加是$\\Theta(\\sqrt{n})$的，而查询是$\\Theta(1)$的。结合起来效率是$\\Theta(\\sqrt n)$。 再考虑维护每块的点到每个点的距离和。 在修改边权的时候对每块的信息的影响是两个区间加，查询是在$\[L,R\]$中的整块的单点查。 我们改成维护前$i$块的点到每个点的距离和，这样修改边权的时候每块还是两个区间加（加的系数变了），而查询的时候变成两个块的单点查。 我们同样用分块维护，不过这次的分块是修改$\\Theta(1)$的，查询是$\\Theta(\\sqrt n)$的。这样结合起来还是$\\Theta(\\sqrt n)$。 这样我们就把时间和空间都优化到了$\\Theta(n\\sqrt n)$。 但是还有一个问题。 那就是$n\\sqrt{n}$的空间我们开不下啊？？？ 我们把每块的大小变大，这样块数就变少了，调到一个界使得数组开的下即可。 这时你发现你被卡常TLE了 慢慢调参数吧…不过std好像在我们OJ跑不过去