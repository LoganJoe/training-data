---
title: " DTOJ2670侦察守卫\t\t"
tags:
  - 树形dp
url: 135.html
id: 135
categories:
  - DTOJ
  - Solution
date: 2018-01-07 21:33:33
---

这题一看就是树形dp，但是的确比较麻烦。 因为在一个点放护卫可以覆盖上面和下面的点，所以转移时我们需要知道当前子树内的点对现在的影响（还能往上覆盖多少或者是有多少没覆盖）。 我们用\\(f\[x\]\[i\]\\)表示以\\(x\\)为根的子树内，必须覆盖的点已经覆盖，从\\(x\\)还能往上覆盖\\(i\\)步的最小代价。\\(g\[x\]\[i\]\\)表示以\\(x\\)为根的子树内，除了从\\(x\\)往下\\(i\\)层的点（\\(x\\)为第1层），其他点必须覆盖的点都已经覆盖的最小代价。 对于x的一个儿子\\(son\\)，我们可以从\\(son\\)往上走到\\(x\\)再继续走覆盖其他点，即\\(f\[son\]\[i+1\]+g\[x\]\[i+1\]\\)可以更新\\(f\[x\]\[i\]\\)；也可以从\\(x\\)往下走覆盖\\(son\\)，即\\(f\[x\]\[i\]+g\[son\]\[i\]\\)也可以更新\\(f\[x\]\[i\]\\)（前者的\\(f\[x\]\[i\]\\)是还未覆盖\\(son\\)这棵子树，后者的\\(f\[x\]\[i\]\\)是覆盖了\\(son\\)这棵子树）。同时这棵子树也会给\\(g\[x\]\[i\]\\)带来\\(g\[son\]\[i-1\]\\)的代价。 同时显然还有\\(f\[x\]\[i\]=min(f\[x\]\[i\],f\[x\]\[i+1\])，g\[x\]\[i\]=min(g\[x\]\[i\],g\[x\]\[i-1\])\\)。 更新的时候要注意一下顺序。最终的答案即为\\(f\[x\]\[0\]\\)。