---
title: " DTOJ3743djq的朋友圈\t\t"
tags:
  - 状压dp
url: 2277.html
id: 2277
categories:
  - DTOJ
  - Solution
date: 2018-06-08 17:19:47
---

我们把和$1$号点有连边的点称作$A$类点，和$A$类有连边且不是$A$类点的点称作$B$类点。那么我们就是要让$B$类点成为朋友的数目尽量的大。 考虑排列$A$类点的顺序对$B$类点的影响，显然之前$A$类点的顺序对当前确定$B$类点的关系没有影响。我们只用考虑每次新加的一个$A$类点会确定哪些$B$类点的关系。 这显然可以用一个状压dp来完成：记$f\[S\]$为已经排列的$A$类点的状态为$S$，$B$类点中最多可能的朋友数目。 枚举新加的$A$类点转移，很容易做到$\\Theta(n^22^{|A|})$。把每个$A$类点能确定的$B$类点二进制表示压起来，每个$A$类点使能成为朋友的$B$类点也二进制压起来，就可以消去一个$n$，变成$\\Theta(n2^{|A|})$。 注意到$|A|+|B|<42$，那么有$min(|A|,|B|)\\leqslant 20$。这样如果我们有与$2^{|B|}$相关的算法话，就可以解决这道题了。 将之前的状压dp略微改动一下：记$f\[S\]$为已经确定关系的$B$类点的状态为$S$，这些点中最多可能的朋友数目。 同样枚举新加的$A$类点进行转移，如果某个$A$类点不能多确定某个$B$类点的关系，我们就认为这个$A$类点之前已经考虑过了（即已经在之前被加入排列）。预处理一些状态同样可以做到$\\Theta(n2^{|B|})$。 那么我们就用$\\Theta(n2^{min(|A|,|B|)})$的时间复杂度解决了这道题。