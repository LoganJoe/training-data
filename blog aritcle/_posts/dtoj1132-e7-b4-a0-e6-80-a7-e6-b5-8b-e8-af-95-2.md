---
title: " DTOJ1132素性测试\t\t"
tags:
  - 无标签
url: 1784.html
id: 1784
categories:
  - Solution
date: 2018-04-29 18:39:39
---

我们先介绍一种素数测试方法：$Miller-Rabin$筛法。 对于朴素的素数判断法，容易发现它是$O(\\sqrt n)$的。这个素数判断法适用范围已经很广了，但是对于某些$n leq 10^{18}$的数据却无能为力。我们可以用基于随机数的判断方法快速判断一个数是否是质数。 首先我们考虑一个证明：**如果p是素数，a是小于p的正整数，那么a^(p-1) mod p = 1。**在这里我直接引用Matrix67的相关证明。 首先我们证明这样一个结论：如果p是一个素数的话，那么对任意一个小于p的正整数a，a, 2a, 3a, …, (p-1)a除以p的余数正好是一个1到p-1的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。 反证法，假如结论不成立的话，那么就是说有两个小于p的正整数m和n使得na和ma除以p的余数相同。不妨假设n>m，则p可以整除a(n-m)。但p是素数，那么a和n-m中至少有一个含有因子p。这显然是不可能的，因为a和n-m都比p小。 用[同余式](http://www.matrix67.com/blog/article.asp?id=282)表述，我们证明了： $$(p-1)! \\equiv a \\centerdot 2a \\centerdot 3a \\centerdot … \\centerdot (p-1)a (mod p)$$ 也即： $$(p-1)! \\equiv (p-1)! \\centerdot a^{p-1} (mod p)$$ 两边同时除以(p-1)!，就得到了我们的最终结论： $$1 \\equiv a^{p-1} (mod p)$$ 最简单的想法就是，我们刚才只考虑了$a=2$的情况。对于式子$a^{n-1} mod n$，取不同的$a$可能导致不同的结果。一个合数可能在$a=2$时通过了测试，但$a=3$时的计算结果却排除了素数的可能。于是，人们扩展了伪素数的定义，称满足$a^{n-1} mod n = 1$的合数n叫做以$a$为底的伪素数($pseudoprime to base a$)。前10亿个自然数中同时以$2$和$3$为底的伪素数只有$1272$个，这个数目不到刚才的$\\frac{1}{4}$。这告诉我们如果同时验证$a=2$和$a=3$两种情况，算法出错的概率降到了$0.000025$。容易想到，选择用来测试的$a$越多，算法越准确。通常我们的做法是，随机选择若干个小于待测数的正整数作为底数$a$进行若干次测试，只要有一次没有通过测试就立即把 这个数扔回合数的世界。这就是$Ferma$t素性测试。 人们自然会想，如果考虑了所有小于$n$的底数$a$，出错的概率是否就可以降到$0$呢？没想到的是，居然就有这样的合数，它可以通过所有$a$的测试。 Carmichael第一个发现这样极端的伪素数，他把它们称作$Carmichael$数。你一定会以为这样的数一定很大。错。第一个$Carmichael$数小得惊人，仅仅是一个三位数，$561$。前$10$亿个自然数中$Carmichael$数也有$600$个之多。$Carmichael$数的存在说明，我们还需要继续加强素性判断的算法。 $Miller$和$Rabin$两个人的工作让$Fermat$素性测试迈出了革命性的一步，建立了传说中的$Miller-Rabin$素性测试算法。新的测试基于下面的定理：如果$p$是素数，$x$是小于$p$的正整数，且$x^2 mod p = 1$，那么要么$x=1$，要么$x=p-1$。这是显然的，因为$x^2 mod p = 1$相当于p能整除$x^2-1$，也即$p$能整除$(x+1)(x-1)$。由于$p$是素数，那么只可能是$x-1$能被$p$整除(此时$x=1$)或$x+1$能被$p$整除(此时$x=p-1$)。 $Miller-Rabin$素性测试同样是不确定算法，我们把可以通过以$a$为底的$Miller-Rabin$测试的合数称作以$a$为底的强伪素数($strong pseudoprime$)。第一个以$2$为底的强伪素数为$2047$。第一个以$2$和$3$为底的强伪素数则大到$1 373 653$。 $ Miller-Rabin$算法的代码也非常简单：计算$d$和$r$的值（可以用位运算加速），然后二分计算$a^d mod n$的值，最后把它平方$r$次。程序的代码比想像中的更简单，函数IsPrime返回对于特定的底数a，n是否是能通过测试。如果函数返回False，那说明n不是素数；如果函数返回True，那么n极有可能是素数。

ll mul(ll x,ll k,ll n)
{
    ll t=0;
    while(k)
    {
        if(k&1) t=(t+x)%n;
        x=(x+x)%n;k>>=1;
    }
    return t;
}
ll Pow(ll x,ll k,ll n)
{
    ll t=1;
    while(k)
    {
        if(k&1) t=mul(t,x,n);
        x=mul(x,x,n);k>>=1;
    }
    return t;
}
bool test(ll n,ll a,ll d)
{
    if(n==2) return 1;
    if(n==a || !(n&1)) return 0;
    while(!(d&1)) d>>=1;
    ll t=Pow(a,d,n);
    while(d!=n-1&&t!=n-1&&t!=1) t=t*t%n,d<<=1;
    return t==n-1 || (d&1)==1;
}
bool isprime(ll n)
{
    int a\[\]={2,3,5,7,rand()%(n-2)+2,rand()%(n-2)+2,rand()%(n-2)+2};
    for(int i=0;i<=6;i++)
    {
        if(n==a\[i\]) return 1;
        if(!test(n,a\[i\],n-1)) return 0;
    }
    return 1;
}