---
title: " DTOJ1542普通平衡树\t\t"
tags:
  - 平衡树
url: 59.html
id: 59
categories:
  - Solution
date: 2018-01-05 21:24:44
---

[Problem](http://59.61.75.5:8018/problem.php?id=1542) 这题貌似并不是splay板子题。 所有操作都可以使用Treap完成。 这里讲一下删除操作： 对于要删除的点x，我们可以将它splay到根上，如果这个数出现了多个自然可以直接cnt-1，否则特判一下左右儿子的情况（如果有一边的儿子空了，那么root显然可以沉到另外一边，如果两边都没有那么这棵树就被删空了），然后找到这个数的前驱（或者后继），我们令其作为新的根节点。splay上去以后x就会是root的左儿子，而x就不具有左儿子(肯定没有比x小比root大的数），那么将x的右儿子挂到当前根即可。 至于如何找前驱？当前点滚到根上，然后从这玩意的左儿子开始一直往右儿子走就可以了。 Code \[cc lang="php" tab_size="4" lines="40"\] #include<bits/stdc++.h> using namespace std; struct Splay { int son\[2\],fa,size,cnt,v; }t\[100005\]; int n,root,opt,x,cnt; void pushup(int x){t\[x\].size=t\[t\[x\].son\[0\]\].size+t\[t\[x\].son\[1\]\].size+t\[x\].cnt;} void rotate(int x,int &k) { int y=t\[x\].fa,z=t\[y\].fa,l,r; l=(t\[y\].son\[0\]==x)?0:1;r=l^1; if(y==k) k=x; else if(t\[z\].son\[0\]==y) t\[z\].son\[0\]=x; else t\[z\].son\[1\]=x; t\[x\].fa=z,t\[y\].fa=x,t\[t\[x\].son\[r\]\].fa=y; t\[y\].son\[l\]=t\[x\].son\[r\],t\[x\].son\[r\]=y; pushup(y),pushup(x); } void splay(int x,int &k) { while(x!=k) { int y=t\[x\].fa,z=t\[y\].fa; if(y!=k) { if(t\[z\].son\[0\]==y^t\[y\].son\[0\]==x) rotate(x,k); rotate(y,k); } rotate(x,k); } } int create(int x){t\[++cnt\].v=x,t\[cnt\].size=t\[cnt\].cnt=1;return cnt;} void insert(int x) { if(root) { int now=root,fa=0; while(1) { if(!now) { create(x);t\[cnt\].fa=fa; t\[fa\].son\[(t\[fa\].v<=x)\]=cnt; pushup(fa),splay(cnt,root); return ; } if(t\[now\].v==x) { t\[now\].cnt++;pushup(now),pushup(fa),splay(now,root);return ; } fa=now,now=t\[now\].son\[(t\[now\].v<=x)\]; } } else root=create(x); } int findpos(int x) { int now=root,ret=0; while(1) { if(t\[now\].v>x) now=t\[now\].son\[0\]; else { ret+=t\[t\[now\].son\[0\]\].size; if(t\[now\].v==x) {splay(now,root);return ret+1;} ret+=t\[now\].cnt,now=t\[now\].son\[1\]; } } } int findpit(int x) { int now=root; while(1) { if(t\[t\[now\].son\[0\]\].size<x) { x-=t\[t\[now\].son\[0\]\].size; if(x<=t\[now\].cnt) {splay(now,root);return t\[now\].v;} x-=t\[now\].cnt,now=t\[now\].son\[1\]; } else now=t\[now\].son\[0\]; } } int pre() { int now=t\[root\].son\[0\]; while(t\[now\].son\[1\]) now=t\[now\].son\[1\]; return now; } int nex() { int now=t\[root\].son\[1\]; while(t\[now\].son\[0\]) now=t\[now\].son\[0\]; return now; } void Delete(int x) { findpos(x); if(t\[root\].cnt>1){t\[root\].cnt--,t\[root\].size--;return ;} if(!t\[root\].son\[0\] && !t\[root\].son\[1\]) {root=0;return ;} if(!t\[root\].son\[0\]) {root=t\[root\].son\[1\],t\[root\].fa=0;return ;} if(!t\[root\].son\[1\]) {root=t\[root\].son\[0\],t\[root\].fa=0;return ;} int newroot=pre(),las=root; splay(newroot,root); t\[root\].son\[1\]=t\[las\].son\[1\],t\[t\[las\].son\[1\]\].fa=root; pushup(root); } void findpre(int x){insert(x),printf("%d\\n",t\[pre()\].v),Delete(x);} void findnex(int x){insert(x),printf("%d\\n",t\[nex()\].v),Delete(x);} int main() { scanf("%d",&n); while(n--) { scanf("%d%d",&opt,&x); if(opt==1) insert(x); if(opt==2) Delete(x); if(opt==3) printf("%d\\n",findpos(x)); if(opt==4) printf("%d\\n",findpit(x)); if(opt==5) findpre(x); if(opt==6) findnex(x); } } \[/cc\]